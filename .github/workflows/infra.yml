name: Infrastructure & Deploy

on:
  # push:
  #   branches: [ master ]
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Manual Release Type'
        required: false
        default: 'auto'
        type: choice
        options:
        - auto
        - patch
        - minor
        - major

permissions:
  id-token: write
  contents: write

jobs:
  release:
    name: Calculate Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.tag_version.outputs.new_tag }}
      changelog: ${{ steps.tag_version.outputs.changelog }}
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: Bump version and push tag
        id: tag_version
        uses: mathieudutour/github-tag-action@v6.1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          default_bump: patch
          custom_release_type: ${{ inputs.release_type != 'auto' && inputs.release_type || '' }}

  persistent:
    name: Deploy Persistent Infrastructure
    needs: release
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./infra/persistent
    steps:
    - name: Checkout
      uses: actions/checkout@v3

    - name: Setup OpenTofu
      uses: opentofu/setup-opentofu@v1

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: us-east-1

    - name: OpenTofu Init
      run: tofu init

    - name: OpenTofu Format
      run: tofu fmt -check

    - name: OpenTofu Plan
      env:
        TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}
        TF_VAR_anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
        TF_VAR_google_api_key: ${{ secrets.GOOGLE_API_KEY }}
      run: tofu plan -input=false

    - name: OpenTofu Apply
      if: github.ref == 'refs/heads/master'
      env:
        TF_VAR_openai_api_key: ${{ secrets.OPENAI_API_KEY }}
        TF_VAR_anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
        TF_VAR_google_api_key: ${{ secrets.GOOGLE_API_KEY }}
      run: tofu apply -auto-approve -input=false

  teardown:
    name: Deploy Application Infrastructure
    needs: [release, persistent]
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./infra/teardown
    outputs:
      private_subnets: ${{ steps.tf-outputs.outputs.private_subnets }}
      security_group_id: ${{ steps.tf-outputs.outputs.security_group_id }}
    steps:
    - name: Checkout
      uses: actions/checkout@v3

    - name: Setup OpenTofu
      uses: opentofu/setup-opentofu@v1

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: us-east-1

    - name: OpenTofu Init
      run: tofu init

    - name: OpenTofu Format
      run: tofu fmt -check

    - name: OpenTofu Plan
      env:
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_app_db_password: ${{ secrets.APP_DB_PASSWORD }}
        TF_VAR_image_tag: ${{ needs.release.outputs.version }}
      run: tofu plan -input=false

    - name: OpenTofu Apply
      if: github.ref == 'refs/heads/master'
      env:
        TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
        TF_VAR_app_db_password: ${{ secrets.APP_DB_PASSWORD }}
        TF_VAR_image_tag: ${{ needs.release.outputs.version }}
      run: tofu apply -auto-approve -input=false

    - name: Export Terraform Outputs
      id: tf-outputs
      if: github.ref == 'refs/heads/master'
      run: |
        echo "private_subnets=$(tofu output -json private_subnets | jq -r 'join(",")')" >> $GITHUB_OUTPUT
        echo "security_group_id=$(tofu output -raw ecs_tasks_security_group_id)" >> $GITHUB_OUTPUT

  build:
    needs: [persistent, teardown, release]
    if: github.ref == 'refs/heads/master'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service:
          - name: message-service
            dockerfile: Dockerfile.message-service
            repo: collm-message-service
          - name: user-service
            dockerfile: Dockerfile.user-service
            repo: collm-user-service
          - name: core-service
            dockerfile: Dockerfile.core-service
            repo: collm-core-service
          - name: migrator
            dockerfile: Dockerfile.migrator
            repo: collm-migrator
          - name: web
            dockerfile: Dockerfile.web
            repo: collm-web
    steps:
    - name: Checkout
      uses: actions/checkout@v3

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: us-east-1

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Build, tag, and push ${{ matrix.service.name }}
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ matrix.service.repo }}
        IMAGE_TAG: ${{ needs.release.outputs.version }}
      run: |
        docker build -f ${{ matrix.service.dockerfile }} -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

  migrate:
    needs: [teardown, build]
    if: github.ref == 'refs/heads/master'
    runs-on: ubuntu-latest
    steps:
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: us-east-1

    - name: Run Database Migrations
      env:
        SUBNETS: ${{ needs.teardown.outputs.private_subnets }}
        SECURITY_GROUP: ${{ needs.teardown.outputs.security_group_id }}
      run: |
        TASK_ARN=$(aws ecs run-task \
          --cluster collm-cluster \
          --task-definition collm-migrator \
          --launch-type FARGATE \
          --network-configuration "awsvpcConfiguration={subnets=[$SUBNETS],securityGroups=[$SECURITY_GROUP],assignPublicIp=DISABLED}" \
          --query "tasks[0].taskArn" --output text)
        
        echo "Started migration task: $TASK_ARN"
        echo "Waiting for migration task to complete..."
        
        aws ecs wait tasks-stopped --cluster collm-cluster --tasks $TASK_ARN
        
        EXIT_CODE=$(aws ecs describe-tasks --cluster collm-cluster --tasks $TASK_ARN --query "tasks[0].containers[0].exitCode" --output text)
        
        if [ "$EXIT_CODE" != "0" ]; then
          echo "Migration task failed with exit code $EXIT_CODE"
          exit 1
        else
          echo "Migration task completed successfully"
        fi

  deploy:
    needs: migrate
    if: github.ref == 'refs/heads/master'
    runs-on: ubuntu-latest
    steps:
    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: us-east-1

    - name: Force ECS Deployment
      run: |
        aws ecs update-service --cluster collm-cluster --service collm-user-service --force-new-deployment
        aws ecs update-service --cluster collm-cluster --service collm-core-service --force-new-deployment
        aws ecs update-service --cluster collm-cluster --service collm-web --force-new-deployment
        aws ecs update-service --cluster collm-cluster --service collm-message-service --force-new-deployment
